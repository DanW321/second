---
title: "Random Forest Labeling"
knit: (function(inputFile, encoding) { 
          rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file='html_files/rf_labeling.html') })
output:
  html_document:
    theme: default
    highlight: pygments
    toc: true
    toc_depth: 3
    toc_float: true
editor_options:
  chunk_output_type: console
---
Author: Dan Wexler\
Date: `r Sys.Date()`

This script applies a trained random forest model to unseen landscape
disturbance patches. Below is a list of the inputs and outputs.\
\
INPUTS: (in '4_labeling_input' and '3_intermediate')\
1) .csv file generated by Google Earth Engine and ArcGIS Pro containing 
predictor variable information for disturbance polygons. (UPLOAD)\
2) Trained random forest model.\
3) List of variables used in the trained random forest model.\
4) Table of model probabilities from the training script.\
5) Table of omission error rates from the training script.\
OUTPUTS: (in '5_output')\
1) A table containing the unique ids for each disturbance patch, the label
generated by the random forest model, the probability assigned by the model
of that label being a certain disturbance class, and a flag indicating whether
that label should be accepted or rejected based on the probability. This
information is also included for secondary classifications.

### (1) Setup
Here we load the R libraries that are used throughout the script. Some or all 
of them may have to be downloaded.
```{r setup 1, message = FALSE, warning = FALSE}
# loads R libraries
library(randomForest)
library(DT)
library(dplyr)
library(here)
```

This block of code contains variables that the user can modify to fit their
specific needs. This is the only block of code that requires user input,
barring more involved modification of the script. The in-line comments detail
specifically what each variable represents.
```{r setup 2}
# the name of the park (MORA, OLYM, or NOCA)
park <- "MORA"
# the name of the file containing the predictor variables
predictors_file <- "predictors.csv"
# the name of the file that will store labels generated by the model
save_name <- "disturbance_labels.csv"
# if TRUE, filters out patches in the elevation/vegetation mask
filter_out_mask <- FALSE
# if TRUE, filters out patches from the year 1987
drop_1987 <- TRUE
# ---------------------------------------------------------------------------- #
# THE NEXT FOUR VARIABLES CONTROL WHICH PATCHES ARE INCLUDED IN THE LABELING
# PROCESS AND WHICH ARE FILTERED OUT. SET ONE (AND ONLY ONE) TO TRUE. IF ALL
# FOUR ARE SET TO FALSE, THE ENTIRE STUDY AREA IS INCLUDED IN LABEING
# ---------------------------------------------------------------------------- #
# if TRUE, filters patches to those within the protected areas and buffer
label_pa_and_buffer <- TRUE
# if TRUE, filters patches to those within the park and buffer
label_park_and_buffer <- FALSE
# if TRUE, filters patches to those within the protected areas
label_pa <- FALSE
# if TRUE, filters patches to those within the park
label_park <- FALSE
# ---------------------------------------------------------------------------- #
# the number of each disturbance type to be flagged for QA/QC sampling
sample_size <- 50
# the probability cutoffs at which to accept model labels for each
# disturbance type, determined using the training script - set to NA
# if there is no suitable probability cutoff or a certain disturbance type
# is not being labeled by the current model
probability_cutoffs <- c("Annual Variability" = 0,
                         "Avalanche" = 40,
                         "Blowdown" = 40,
                         "Clearing" = NA, 
                         "Defoliation" = 0, 
                         "Development" = NA, 
                         "Fire" = 0, 
                         "Ice Damage" = NA, 
                         "Mass Movement" = NA, 
                         "Post Avalanche" = NA, 
                         "Post Blowdown" = NA, 
                         "Post Clearing" = NA,
                         "Post Defoliation" = NA,
                         "Post Fire" = NA, 
                         "Post Mass Movement" = NA,
                         "Riparian Change" = 0, 
                         "Water" = NA)
```

This block of code contains a function for displaying tables that will be used
throughout the script.
```{r setup 3}
# function for displaying tables
create_table <- function(table, title, rows) {
  # displays the table
  DT::datatable(table, class = "cell-border stripe hover",
                rownames = rows, caption = paste(park, "|", title),
                options = list(pageLength = nrow(table), dom = "t",
                               order = list(classes = "no-sort")))
}
```

Now we load and clean the inputs to this script, which include
a list of variables used in the random forest model, an array of predictor
variables for each disturbance patch, the trained random forest model, and
model probability cutoffs and omission error rates for reference.
```{r setup 4}
# loads the list of variables that the model will use to make classifications
file_name <- paste0("best_rf_variables_", park, ".csv")
variables <- read.csv(here(park, "3_intermediate", file_name))[,1]
# loads the predictor variables
x <- read.csv(here(park, "4_labeling_input", predictors_file))
# filters out patches within the elevation mask 
if (filter_out_mask) {
  x <- x[x$In_Mask != "Yes",]
}
# filters out patches from the year 1987
if (drop_1987) {
  x <- x[x$yod != 1987,]
}
# filters patches based on location in the study area
if (label_pa_and_buffer) {
  x <- x[which(x$Protected == "Yes" | x$In_Buffer == "Yes"),]
} else if (label_park_and_buffer) {
  x <- x[which(x$In_Park == "Yes" | x$In_Buffer == "Yes"),]
} else if (label_pa) {
  x <- x[x$Protected == "Yes",]
} else if (label_park) {
  x <- x[x$In_Park == "Yes",]
}
# extracts a list of unique patch ids
ids <- data.frame(x$patch_name)
# filters the predictor variables using the loaded list of variables
x <- subset(x, select = variables)
# converts the variables to numeric and changes NA values to 0
x <- data.frame(sapply(x, as.numeric))
x[is.na(x)] <- 0
# loads the trained random forest model
file_name <- paste0("best_rf_model_", park, ".RData")
forest <- readRDS(here(park, "3_intermediate", file_name))
disturbances <- rownames(forest$confusion)
# loads the model probability cutoffs and associated error rates
file_name <- paste0("best_rf_probabilities_", park, ".csv")
cutoff <- data.frame(read.csv(here(park, "3_intermediate", file_name)))
cutoff <- cutoff[,2:ncol(cutoff)]
file_name <- paste0("best_rf_errors_", park, ".csv")
errors <- read.csv(here(park, "3_intermediate", file_name))
errors <- errors[,2:ncol(errors)]
```

### (2) Labeling
We are now ready to apply the random forest model and label disturbance patches.
This block of code feeds the predictor variables through the model, then
analyzes the voting results to determine whether a particular label is
'acceptable' based on the probability thresholds set by the user. The result
of this section is a table that contains the unique id for each disturbance
patch, the best label generated by the model, the probability at which that
classification was made, and whether that classification is acceptable. The
label, probability, and acceptance columns are also displayed for the
classification that received the second most votes. The first 10 rows of the 
output are shown as an example, with the patch IDs hidden for display.\
\
This code defines a function that checks if a classification is acceptable...
```{r labeling 1}
# a function that checks if a certain classification is acceptable
check_threshold <- function(votes, ind) {
  # gets the disturbance label
  label <- votes[ind, 1]
  # gets the probability of classification
  prob <- votes[ind, 2] * 100
  # gets the probability threshold for the disturbance type
  threshold <- probability_cutoffs[label]
  # if the probability of classification is greater than both the threshold 
  # and 1/k where k is the number of disturbances, change the 'accept' flag to 
  # 'yes', otherwise 'no'
  accept <- "no"
  if (!is.na(threshold)) {
    if (prob >= threshold & prob >= 100 / length(disturbances)) {
      accept <- "yes"
    } 
  }
  # return the accept flag
  return (accept)
}
```

...and this code uses the function to label the disturbance patches.
```{r labeling 2}
# applies the random forest model and gets voting distributions
predictions <- as.data.frame(predict(forest, x, type = "prob"))
# creates a data frame to store results
results <- data.frame(matrix(NA, nrow(predictions), 7))
results[,1] <- ids
colnames(results) <- c("ID", "Label1", "Prob1", "Accept1", "Label2", "Prob2", "Accept2")
# loops through the disturbance patches
for (i in 1:nrow(predictions)) {
  # gets the voting distribution
  to_sort <- data.frame(Label = disturbances, Errors = as.numeric(predictions[i,]))
  # sorts the voting distribution
  sorted <- to_sort[order(to_sort$Errors, decreasing = TRUE),]
  # gets the the disturbance(s) with the highest probabilities
  best_ind <- which(sorted[,2] == max(sorted[,2]))
  next_ind <- 2
  # if there is a tie for most likely disturbance, randomly select between
  # the tied disturbances
  if (length(best_ind) > 1) {
    pick <- sample(best_ind, 2, replace = FALSE)
    best_ind <- pick[1]
    next_ind <- pick[2]
  }
  # store the results
  results[i,2] <- sorted[best_ind, 1]
  results[i,3] <- round(sorted[best_ind, 2] * 100, 2)
  results[i,4] <- check_threshold(sorted, best_ind)
  results[i,5] <- sorted[next_ind, 1]
  results[i,6] <- round(sorted[next_ind, 2] * 100, 2)
  results[i,7] <- check_threshold(sorted, next_ind)
}
# displays the first ten rows of labeling results
caption <- "First 10 rows of labeling results (patch IDs are hidden)"
create_table(results[1:10, 2:7], caption, FALSE)
```

This block adds a new column to the label array shown above containing a flag
that indicates whether that particular disturbance patch will be a part of the
QAQC process. In this run, `r sample_size` patches of each disturbance type are
randomly chosen for QAQC. If there are fewer than `r sample_size` of a certain 
type of disturbance, all of the patches of that type are flagged for QAQC.
```{r labeling 3}
# adds a new column for QAQC flags to results array
results$QAQC <- FALSE
# loops through each disturbance type
for (i in 1:length(disturbances)) {
  dist <- disturbances[i]
  # filter the results array by disturbance type
  indices <- which(results$Label1 == dist&results$Accept1 == "yes")
  # find the number of accepted disturbances
  num_dists <- length(indices)
  # if there are any disturbances of the current type
  if (num_dists > 0) {
    samp <- 0
    # if there are fewer than a critical number of disturbances, set the sample
    # size equal to the number of disturbances, otherwise set the sample size 
    # equal to the user chosen value
    if (num_dists < sample_size) {
      samp <- num_dists
    } else {
      samp <- sample_size
    }
    # flag a random selection of the current disturbance type for QAQC
    rand_indices <- sample(indices, samp, replace = FALSE)
    results[rand_indices, "QAQC"] <- TRUE
  }
}
```

### (3) Saving Results
This section saves the labeled disturbance patches (along with probability and
acceptance information).
```{r saving results}
# saves the labeled disturbance patches
write.csv(results, file = here(park, "5_output", save_name), row.names = FALSE)
```

### (4) Analysis
This section analyzes the labeling results. We look at the distribution of 
labeled disturbances, the acceptance percentages, and more. 
```{r analysis 1}
# creates a data frame to store results
analysis <- data.frame(matrix(NA, length(disturbances), 6))
analysis[,1] <- disturbances
colnames(analysis) <- c("Disturbance", "Total", "Accepted", "% Accepted", "Expected Error %", "Secondary")
# loops through each disturbance type
for (i in 1:length(disturbances)) {
  # gets the current disturbance
  dist <- disturbances[i]
  # filters the labels by the current disturbance type
  total <- results[results$Label1 == dist,]
  # filter the labels by accepted disturbance labels
  accpt <- results[which(results$Label1 == dist&results$Accept1 == "yes"),]
  # filter the labels by accepted secondary disturbance labels
  secnd <- results[which(results$Label2 == dist&results$Accept2 == "yes"&results$Accept1 == "no"),]
  # store the results
  analysis[i, 2] <- nrow(total)
  analysis[i, 3] <- nrow(accpt)
  analysis[i, 4] <- round((nrow(accpt) / nrow(total)) * 100, 2)
  # gets the expected error rate given the user-set model probability cutoff
  threshold <- probability_cutoffs[dist]
  error_rate <- NA
  for (j in 1:ncol(cutoff)) {
    if (!is.na(cutoff[i, j]) & !is.na(threshold)) {
      if (cutoff[i, j] == threshold) {
        error_rate <- errors[i, j]
        break
      }
    }
  }
  analysis[i, 5] <- error_rate
  analysis[i, 6] <- nrow(secnd)
}
# finds the percent of accepted primary labels
num_accepted <- sum(analysis[,3], na.rm = TRUE)
num_patches <- nrow(results)
percent_accepted <- round((num_accepted / num_patches) * 100, 2)
```

------------------------------------------------------------------------------\
Total number of patches with an accepted label: `r num_accepted`\
Total number of patches: `r num_patches`\
% of patches with an accepted label: `r percent_accepted`%\
Number of patches with unaccepted label: `r num_patches - num_accepted`\
------------------------------------------------------------------------------\
```{r analysis 2}
# displays the table described above
create_table(analysis, "Label breakdown", FALSE)
```

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
